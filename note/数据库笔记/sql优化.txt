SQL索引失效
1、如果条件中有or，即使其中有条件带索引也不会使用(这也为什么尽量少用or的原因)
2、对于多列索引，不使用的第一部分，则不会使用索引
3、like查询以%开头
4、如果列类型字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5、如果mysql估计使用全表扫描要比使用索引快,则不使用索引
6、任何在where子句中使用is null或is not null的语句优化器不允许使用索引的。
====================================================================================================================
免在索引列上使用IS NULL和IS NOT NULL
====================================================================================================================
连接（JOIN）之所以更有效率一些
因为 MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作 （少用in）
====================================================================================================================
SELECT子句中避免使用 ‘ * ‘：
ORACLE在解析的过程中, 会将'*' 依次转换成所有的列名, 这个工作通过查询数据字典完成的, 这意味着将耗费更多的时间
====================================================================================================================
最高效的删除重复记录方法 ( 因为使用了ROWID)例子：
DELETE  FROM  EMP E  WHERE  E.ROWID >
(SELECT MIN(X.ROWID) FROM  EMP X  WHERE  X.EMP_NO = E.EMP_NO);
====================================================================================================================
用TRUNCATE替代DELETE：  (译者按: TRUNCATE只在删除全表适用,TRUNCATEDDL不DML)
当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息.
如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说恢复到执行删除命令之前的状况) 而当运用TRUNCATE时,
回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短.
====================================================================================================================
用Where子句替换HAVING子句： on、where、having这三个都可以加条件的子句中，on最先执行，where次之，having最后
====================================================================================================================
用EXISTS替代IN、用NOT EXISTS替代NOT IN：
在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下,
使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 在子查询中,NOT IN子句将执行一个内部的排序和合并.
无论在哪种情况下,NOT IN都最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,
我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.
====================================================================================================================
a表       		   b表
id   name          id     job   parent_id   
1   张3             1     23     1   
2   李四            2     34     2   
3   王武            3     34     4   
    
  a.id同parent_id   存在关系   
    
  内连接   
  select   a.*,b.*   from   a   inner   join   b     on   a.id=b.parent_id   
    
  结果     
  1   张3   1     23     1   
  2   李四  2     34     2   
    
  左连接   
  select   a.*,b.*   from   a   left   join   b     on   a.id=b.parent_id   
    
  结果     
  1   张3     1     23     1   
  2   李四    2     34     2   
  3   王武   null   

  右连接   
  select   a.*,b.*   from   a   right   join   b     on   a.id=b.parent_id   
    
  结果     
  1   张3     1     23     1   
  2   李四    2     34     2   
  null        3     34     4   
    
  完全连接   
  select   a.*,b.*   from   a   full   join   b     on   a.id=b.parent_id   

  结果     
  1   张3    1     23     1   
  2   李四   2     34     2   
  null       3     34     4   
  3   王武   null
====================================================================================================================       
====================================================================================================================       
====================================================================================================================       
====================================================================================================================       
====================================================================================================================       
====================================================================================================================       
====================================================================================================================       







